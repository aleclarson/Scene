// Generated by CoffeeScript 1.12.4
var Event, Scene, assertType, getInitialValue, isType, modx, type;

assertType = require("assertType");

isType = require("isType");

Event = require("eve");

modx = require("modx");

Scene = require("./Scene");

type = modx.Type("SceneRouter");

type.defineArgs({
  events: Event.Map
});

type.defineValues(function(options) {
  return options;
});

type.defineGetters({
  root: function() {
    return this._root;
  },
  path: function() {
    if (this._root) {
      return this._chains[this._root].path;
    } else {
      return null;
    }
  },
  chain: function() {
    if (this._root) {
      return this._chains[this._root];
    } else {
      return null;
    }
  }
});

type.render(function() {
  var props;
  props = Object.assign({}, this.props);
  return this._scenes.render(props);
});

type.defineMethods({
  addLoader: function(path, loader) {
    assertType(path, String);
    assertType(loader, Function);
    if (this._loaders[path] !== void 0) {
      throw Error("Cannot add same path twice: '" + path + "'");
    }
    this._loaders[path] = loader;
  },
  addLoaders: function(loaders) {
    var loader, path;
    assertType(loaders, Object);
    for (path in loaders) {
      loader = loaders[path];
      this.addLoader(path, loader);
    }
  },
  get: function(path) {
    return this._routes[path];
  },
  set: function(path, options) {
    var scene;
    assertType(path, String);
    if (path === this._root) {
      return;
    }
    if (this._root !== null) {
      scene = this._routes[this._root];
      scene.__onInactive();
    }
    scene = this._load(path, options);
    this._startChain(scene, path);
    this._root = path;
    scene.__onActive();
    return scene;
  },
  insert: function(path, options) {
    var scene;
    assertType(path, String);
    scene = this._load(path, options);
    this._startChain(scene, path);
    return scene;
  },
  remove: function(path) {
    var scene;
    if (path === this._root) {
      this._root = null;
    }
    scene = this._routes[path];
    if (scene === void 0) {
      return;
    }
    if (scene instanceof Scene) {
      this._scenes.remove(scene);
    }
    delete this._routes[path];
  },
  push: function(path, options) {
    var scene;
    assertType(path, String);
    assertType(options, Object.or(Scene.Kind));
    scene = isType(options, Object) ? this._load(path, options) : options;
    this.chain.push(scene, path);
  },
  reset: function() {
    Object.assign(this, getInitialValue());
    this.view.forceUpdate();
  }
});

type.defineValues(getInitialValue = function() {
  return {
    _root: null,
    _scenes: Scene.Collection(),
    _chains: Object.create(null),
    _routes: Object.create(null),
    _loaders: Object.create(null)
  };
});

type.defineMethods({
  _load: function(path, options) {
    var loader, scene;
    scene = this._routes[path];
    if (options instanceof Scene) {
      if (typeof scene === "function") {
        throw Error("Cannot overwrite a scene factory: '" + path + "'");
      }
      if (scene !== void 0) {
        throw Error("A root scene already exists with path: '" + path + "'");
      }
      this._routes[path] = scene = options;
    } else if (scene === void 0) {
      if (!(loader = this._loaders[path])) {
        throw Error("Invalid path: '" + path + "'");
      }
      this._routes[path] = scene = loader();
    }
    if (typeof scene === "function") {
      scene = scene(options);
    } else if (options !== void 0) {
      throw Error("The 'options' argument is only for scene factories!");
    }
    this._scenes.insert(scene);
    return scene;
  },
  _startChain: function(scene, path) {
    var chain;
    if (!this._chains[path]) {
      chain = Scene.Chain();
      chain.push(scene, path);
      this._chains[path] = chain;
    }
  }
});

module.exports = type.build();
