// Generated by CoffeeScript 1.12.4
var Scene, SceneChain, SceneCollection, assertType, getInitialValue, has, isType, modx, type;

assertType = require("assertType");

isType = require("isType");

modx = require("modx");

has = require("has");

SceneCollection = require("./SceneCollection");

SceneChain = require("./SceneChain");

Scene = require("./Scene");

type = modx.Type("SceneRouter");

type.defineGetters({
  root: function() {
    return this._root;
  },
  path: function() {
    var scene;
    if (scene = this.current) {
      return scene.path;
    } else {
      return null;
    }
  },
  current: function() {
    if (this._root) {
      return this._chains[this._root].current;
    } else {
      return null;
    }
  },
  chain: function() {
    if (this._root) {
      return this._chains[this._root];
    } else {
      return null;
    }
  }
});

type.defineMethods({
  addLoader: function(path, loader) {
    assertType(path, String);
    assertType(loader, Function);
    if (this._loaders[path] !== void 0) {
      throw Error("Cannot add same path twice: '" + path + "'");
    }
    this._loaders[path] = loader;
  },
  addLoaders: function(loaders) {
    var loader, path;
    assertType(loaders, Object);
    for (path in loaders) {
      loader = loaders[path];
      this.addLoader(path, loader);
    }
  },
  get: function(path) {
    if (isType(path, Number)) {
      return this._scenes.array[path];
    } else {
      return this._routes[path];
    }
  },
  set: function(path, options) {
    var scene;
    assertType(path, String);
    if (path === this._root) {
      return this._routes[path];
    }
    if (this._root !== null) {
      scene = this._chains[this._root].current;
      scene.__onInactive();
    }
    scene = this._load(path, options);
    if (!isType(options, Object.Maybe)) {
      options = void 0;
    }
    this._root = scene.path;
    this._markActive(scene, options);
    return scene;
  },
  insert: function(path, options) {
    assertType(path, String);
    return this._load(path, options);
  },
  push: function(path, options) {
    var scene;
    assertType(path, String);
    if (!this._root) {
      throw Error("Cannot call 'push' before 'set'!");
    }
    scene = this._load(path, options);
    if (!isType(options, Object.Maybe)) {
      options = void 0;
    }
    this._chains[this._root].push(scene, options);
    return scene;
  },
  pop: function() {
    var scene;
    if (!this._root) {
      return null;
    }
    scene = this._chains[this._root].pop();
    if (scene.path === this._root) {
      delete this._chains[this._root];
      this._root = null;
    }
    if (!scene.isPermanent) {
      this._scenes.remove(scene);
      delete this._routes[scene.path];
    }
    return scene;
  },
  remove: function(path) {
    var chain, current, scene;
    assertType(path, String);
    if (!(scene = this._routes[path])) {
      return null;
    }
    if (path === this._root) {
      this._root = null;
    }
    if (!(chain = scene.chain)) {
      return scene;
    }
    while (chain.length) {
      current = chain.pop();
      if (!current.isPermanent) {
        this._scenes.remove(current);
        delete this._routes[current.path];
      }
      if (scene === current) {
        break;
      }
    }
    if (!chain.length) {
      delete this._chains[path];
    }
    return scene;
  },
  reset: function() {
    Object.assign(this, getInitialValue());
    this.view.forceUpdate();
  }
});

type.render(function() {
  var props;
  props = Object.assign({}, this.props);
  if (props.style == null) {
    props.style = this.styles.container();
  }
  return this._scenes.render(props);
});

type.defineStyles({
  container: {
    cover: true,
    backgroundColor: "#000"
  }
});

type.defineValues(getInitialValue = function() {
  return {
    _root: null,
    _scenes: SceneCollection(),
    _chains: Object.create(null),
    _routes: Object.create(null),
    _loaders: Object.create(null)
  };
});

type.defineMethods({
  _load: function(path, options) {
    var loader, scene;
    if (isType(options, Object.Maybe)) {
      if (scene = this._routes[path]) {
        return scene;
      }
      if (!(loader = this._loaders[path])) {
        throw Error("Failed to load scene: '" + path + "'");
      }
      scene = loader();
      if (typeof scene === "function") {
        scene = scene(options);
      }
    } else if (has(this._loaders, path)) {
      throw Error("Cannot overwrite a scene loader: '" + path + "'");
    } else if (has(this._routes, path)) {
      throw Error("Cannot overwrite an existing scene: '" + path + "'");
    } else {
      scene = options;
    }
    if (!(scene instanceof Scene)) {
      throw Error("Expected a kind of Scene!");
    }
    if (scene.path == null) {
      scene.path = path;
    }
    this._routes[scene.path] = scene;
    this._scenes.insert(scene);
    return scene;
  },
  _markActive: function(scene, options) {
    var chain;
    if (scene.chain) {
      scene.__onActive(options);
      return;
    }
    chain = SceneChain();
    chain.push(scene, options);
    this._chains[scene.path] = chain;
  }
});

module.exports = type.build();
