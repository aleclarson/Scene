// Generated by CoffeeScript 1.12.4
var Children, Event, ReactUpdateQueue, Scene, SceneTree, Style, View, emptyFunction, modx, ref, type;

ref = require("react-validators"), Style = ref.Style, Children = ref.Children;

ReactUpdateQueue = require("ReactUpdateQueue");

emptyFunction = require("emptyFunction");

Event = require("eve");

View = require("modx/lib/View");

modx = require("modx");

SceneTree = require("./SceneTree");

type = modx.Type("Scene");

type.defineStatics({
  find: function(view) {
    return SceneTree.findScene(view);
  },
  Chain: {
    lazy: function() {
      return require("./SceneChain");
    }
  },
  Collection: {
    lazy: function() {
      return require("./SceneCollection");
    }
  },
  Router: {
    lazy: function() {
      return require("./SceneRouter");
    }
  }
});

type.defineArgs({
  level: Number,
  isHidden: Boolean,
  isPermanent: Boolean,
  ignoreTouches: Boolean,
  ignoreTouchesBelow: Boolean
});

type.defineFrozenValues(function() {
  return {
    didMount: Event(),
    didUpdate: Event()
  };
});

type.defineReactiveValues(function(options) {
  var ref1;
  return {
    isHidden: options.isHidden === true,
    isPermanent: options.isPermanent === true,
    ignoreTouches: options.ignoreTouches === true,
    ignoreTouchesBelow: options.ignoreTouchesBelow === true,
    _level: (ref1 = options.level) != null ? ref1 : 0,
    _chain: null,
    _collection: null
  };
});

type.defineReactions({
  _containerOpacity: function() {
    if (this._chain && this._chain.isHidden) {
      return 0;
    }
    if (this.isHidden) {
      return 0;
    }
    return 1;
  },
  _containerEvents: function() {
    if (this._chain && this._chain.isHidden) {
      return "none";
    }
    if (this.isHidden) {
      return "none";
    }
    return "box-none";
  },
  _foregroundEvents: function() {
    if (this.isTouchable) {
      return "box-none";
    }
    return "none";
  },
  _backgroundEvents: function() {
    if (this.isTouchableBelow) {
      return "none";
    }
    return "auto";
  }
});

type.defineGetters({
  chain: function() {
    return this._chain;
  },
  collection: function() {
    return this._collection;
  },
  isTouchable: function() {
    return !this.ignoreTouches;
  },
  isTouchableBelow: function() {
    return this.ignoreTouches || !this.ignoreTouchesBelow;
  }
});

type.definePrototype({
  level: {
    get: function() {
      return this._level;
    },
    set: function(newValue) {
      if (this.view) {
        throw Error("Cannot set scene level while mounted!");
      }
      return this._level = newValue;
    }
  }
});

type.defineMethods({
  onceMounted: function(callback) {
    if (this.view && ReactUpdateQueue.isMounted(this.view)) {
      return callback();
    } else {
      return this.didMount.once(callback);
    }
  }
});

type.defineHooks({
  __onInsert: emptyFunction,
  __onActive: emptyFunction,
  __onInactive: emptyFunction,
  __onRemove: emptyFunction
});

type.didMount(function() {
  SceneTree._addScene(this);
  return this.didMount.emit();
});

type.didUpdate(function() {
  return this.didUpdate.emit();
});

type.willUnmount(function() {
  return SceneTree._removeScene(this);
});

type.defineProps({
  style: Style,
  children: Children
});

type.render(function() {
  return View({
    style: this.styles.container(),
    pointerEvents: this._containerEvents,
    children: [this._renderBackground(), this._renderForeground()]
  });
});

type.defineMethods({
  _renderBackground: function() {
    return View({
      style: this.styles.background(),
      pointerEvents: this._backgroundEvents,
      onStartShouldSetResponder: emptyFunction.thatReturnsTrue,
      children: this.__renderBackground()
    });
  },
  _renderForeground: function() {
    return View({
      style: this.styles.foreground(),
      pointerEvents: this._foregroundEvents,
      children: this.__renderForeground()
    });
  }
});

type.defineHooks({
  __renderForeground: function() {
    return this.props.children;
  },
  __renderBackground: emptyFunction
});

type.defineStyles({
  container: {
    cover: true,
    clear: true,
    opacity: function() {
      return this._containerOpacity;
    }
  },
  background: {
    cover: true,
    clear: true
  },
  foreground: {
    cover: true,
    clear: true
  }
});

module.exports = Scene = type.build();
