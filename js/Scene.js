// Generated by CoffeeScript 1.11.1
var Children, Event, ReactUpdateQueue, Scene, SceneTree, Style, View, emptyFunction, modx, ref, type;

ref = require("react-validators"), Style = ref.Style, Children = ref.Children;

ReactUpdateQueue = require("ReactUpdateQueue");

emptyFunction = require("emptyFunction");

Event = require("Event");

View = require("modx/lib/View");

modx = require("modx");

SceneTree = require("./SceneTree");

type = modx.Type("Scene");

type.defineStatics({
  find: function(view) {
    return SceneTree.findScene(view);
  },
  Chain: {
    lazy: function() {
      return require("./SceneChain");
    }
  },
  Collection: {
    lazy: function() {
      return require("./SceneCollection");
    }
  }
});

type.defineOptions({
  level: Number.withDefault(0),
  isHidden: Boolean.withDefault(false),
  isPermanent: Boolean.withDefault(false),
  ignoreTouches: Boolean.withDefault(false),
  ignoreTouchesBelow: Boolean.withDefault(false)
});

type.defineFrozenValues(function() {
  return {
    didMount: Event(),
    didUpdate: Event()
  };
});

type.defineReactiveValues(function(options) {
  return {
    isHidden: options.isHidden,
    isPermanent: options.isPermanent,
    ignoreTouches: options.ignoreTouches,
    ignoreTouchesBelow: options.ignoreTouchesBelow,
    _level: options.level,
    _chain: null,
    _collection: null
  };
});

type.defineReactions({
  _containerOpacity: function() {
    if (this._chain && this._chain.isHidden) {
      return 0;
    }
    if (this.isHidden) {
      return 0;
    }
    return 1;
  },
  _containerEvents: function() {
    if (this._chain && this._chain.isHidden) {
      return "none";
    }
    if (this.isHidden) {
      return "none";
    }
    return "box-none";
  },
  _foregroundEvents: function() {
    if (this.isTouchable) {
      return "box-none";
    }
    return "none";
  },
  _backgroundEvents: function() {
    if (this.isTouchableBelow) {
      return "none";
    }
    return "auto";
  }
});

type.defineGetters({
  parent: function() {
    if (this._chain) {
      return this._chain._parent;
    }
    if (this._collection) {
      return this._collection._parent;
    }
    return null;
  },
  isTouchable: function() {
    return !this.ignoreTouches;
  },
  isTouchableBelow: function() {
    return this.ignoreTouches || !this.ignoreTouchesBelow;
  }
});

type.definePrototype({
  chain: {
    get: function() {
      return this._chain;
    },
    set: function(newValue, oldValue) {
      if (newValue === void 0) {
        newValue = null;
      }
      if (newValue !== oldValue) {
        if (oldValue != null) {
          oldValue.remove(this);
        }
        if (newValue != null) {
          assertType(newValue, Scene.Chain);
          newValue.push(this);
        }
      }
    }
  },
  collection: {
    get: function() {
      return this._collection;
    },
    set: function(newValue, oldValue) {
      if (newValue !== oldValue) {
        if (oldValue != null) {
          oldValue.remove(this);
        }
        if (newValue != null) {
          assertType(newValue, Scene.Collection);
          newValue.insert(this);
        }
      }
    }
  },
  level: {
    get: function() {
      return this._level;
    },
    set: function(newValue) {
      if (this.view) {
        throw Error("Cannot set scene level while mounted!");
      }
      return this._level = newValue;
    }
  }
});

type.defineMethods({
  onceMounted: function(callback) {
    var listener;
    if (this.view && ReactUpdateQueue.isMounted(this.view)) {
      callback();
      return;
    }
    listener = this.didMount(1, callback);
    return listener.start();
  }
});

type.defineHooks({
  __onInsert: emptyFunction,
  __onActive: emptyFunction,
  __onInactive: emptyFunction,
  __onRemove: emptyFunction
});

type.didMount(function() {
  SceneTree._addScene(this);
  return this.didMount.emit();
});

type.didUpdate(function() {
  return this.didUpdate.emit();
});

type.willUnmount(function() {
  return SceneTree._removeScene(this);
});

type.defineProps({
  style: Style,
  children: Children
});

type.render(function() {
  return View({
    style: this.styles.container(),
    pointerEvents: this._containerEvents,
    children: [this._renderBackground(), this._renderForeground()]
  });
});

type.defineMethods({
  _renderBackground: function() {
    return View({
      style: this.styles.background(),
      pointerEvents: this._backgroundEvents,
      onStartShouldSetResponder: emptyFunction.thatReturnsTrue,
      children: this.__renderBackground()
    });
  },
  _renderForeground: function() {
    return View({
      style: this.styles.foreground(),
      pointerEvents: this._foregroundEvents,
      children: this.__renderForeground()
    });
  }
});

type.defineHooks({
  __renderForeground: function() {
    return this.props.children;
  },
  __renderBackground: emptyFunction
});

type.defineStyles({
  container: {
    cover: true,
    clear: true,
    opacity: function() {
      return this._containerOpacity;
    }
  },
  background: {
    cover: true,
    clear: true
  },
  foreground: {
    cover: true,
    clear: true
  }
});

module.exports = Scene = type.build();
