// Generated by CoffeeScript 1.11.1
var Event, Scene, SceneTree, SortedArray, Style, View, assertType, emptyFunction, modx, sync, type;

Style = require("react-validators").Style;

emptyFunction = require("emptyFunction");

SortedArray = require("sorted-array");

assertType = require("assertType");

Event = require("Event");

View = require("modx/lib/View");

sync = require("sync");

modx = require("modx");

SceneTree = require("./SceneTree");

Scene = require("./Scene");

type = modx.Type("SceneCollection");

type.defineStatics({
  find: function(view) {
    return SceneTree.findCollection(view);
  }
});

type.defineOptions({
  parent: Scene.Kind
});

type.defineValues(function(options) {
  return {
    _parent: options.parent,
    _elements: {},
    _scenes: SortedArray.comparing("level"),
    _didUpdate: Event()
  };
});

type.defineGetters({
  array: function() {
    return this._scenes.array;
  },
  visible: function() {
    return this._scenes.array.filter(function(scene) {
      return !scene.isHidden;
    });
  },
  hidden: function() {
    return this._scenes.array.filter(function(scene) {
      return scene.isHidden;
    });
  }
});

type.defineMethods({
  insert: function(scene, onUpdate) {
    assertType(onUpdate, Function.Maybe);
    if (Array.isArray(scene)) {
      scene.forEach((function(_this) {
        return function(scene) {
          return _this.insert(scene);
        };
      })(this));
      if (onUpdate) {
        this._didUpdate(1, onUpdate).start();
      }
      return;
    }
    assertType(scene, Scene.Kind);
    if (scene.collection === this) {
      return;
    }
    if (scene.collection !== null) {
      throw Error("Scenes can only belong to one collection at a time!");
    }
    this._scenes.insert(scene);
    scene._collection = this;
    scene.__onInsert(this);
    if (onUpdate) {
      this._didUpdate(1, onUpdate).start();
    }
    if (this.view) {
      this.view.forceUpdate();
    }
  },
  remove: function(scene) {
    var index;
    assertType(scene, Scene.Kind);
    if (scene.collection !== this) {
      throw Error("Scene does not belong to this collection!");
    }
    scene.__onRemove(this);
    scene._collection = null;
    index = this._scenes.array.indexOf(scene);
    this._scenes.array.splice(index, 1);
    delete this._elements[scene.__name];
    this.view && this.view.forceUpdate();
  },
  searchBelow: function(scene, filter) {
    var i, len, ref, result, results;
    assertType(scene, Scene.Kind);
    if (scene.collection !== this) {
      throw Error("Scene does not belong to this collection!");
    }
    if (filter == null) {
      filter = emptyFunction.thatReturnsTrue;
    }
    results = [];
    ref = this._scenes.array;
    for (i = 0, len = ref.length; i < len; i++) {
      result = ref[i];
      if (result === scene) {
        return;
      }
      if (!filter(result)) {
        continue;
      }
      results.push(result);
    }
    return results;
  }
});

type.shouldUpdate(function() {
  return false;
});

type.didMount(function() {
  return this._didUpdate.emit();
});

type.didUpdate(function() {
  return this._didUpdate.emit();
});

type.defineProps({
  style: Style
});

type.render(function() {
  var children, elements, keys;
  if (isDev) {
    keys = [];
  }
  elements = this._elements;
  children = sync.map(this._scenes.array, function(scene) {
    var key;
    key = scene.__name;
    if (isDev) {
      if (0 <= keys.indexOf(key)) {
        throw Error("Duplicate scene name: '" + key + "'");
      }
      keys.push(key);
    }
    return elements[key] || (elements[key] = scene.render({
      key: key
    }));
  });
  return View({
    style: this.props.style,
    children: children
  });
});

module.exports = type.build();
