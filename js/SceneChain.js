// Generated by CoffeeScript 1.11.1
var Scene, SceneTree, Type, assertType, sync, type;

assertType = require("assertType");

Type = require("Type");

sync = require("sync");

SceneTree = require("./SceneTree");

Scene = require("./Scene");

type = Type("SceneChain");

type.defineStatics({
  find: function(view) {
    return SceneTree.findChain(view);
  }
});

type.defineOptions({
  isHidden: Boolean.withDefault(false),
  parent: Scene.Kind
});

type.defineValues(function(options) {
  return {
    _scenes: [],
    _parent: options.parent
  };
});

type.defineReactiveValues(function(options) {
  return {
    isHidden: options.isHidden,
    _last: null
  };
});

type.defineGetters({
  last: function() {
    return this._last;
  },
  scenes: function() {
    return this._scenes;
  }
});

type.defineMethods({
  push: function(scene) {
    assertType(scene, Scene.Kind);
    if (scene.chain !== null) {
      throw Error("Scenes can only belong to one chain at a time!");
    }
    if (this._last) {
      this._last.__onInactive(this);
    }
    scene._chain = this;
    scene.__onActive(this);
    this._scenes.push(scene);
    this._last = scene;
  },
  pop: function() {
    var scene, sceneCount;
    sceneCount = this._scenes.length;
    if (sceneCount === 0) {
      return;
    }
    scene = this._scenes.pop();
    scene._chain = null;
    scene.__onInactive(this);
    if (sceneCount === 1) {
      this._last = null;
      return;
    }
    this._last = this._scenes[sceneCount - 2];
    this._last.__onActive(this);
  },
  remove: function(scene) {
    var index;
    assertType(scene, Scene.Kind);
    if (scene === this._last) {
      return this.pop();
    }
    index = this._scenes.indexOf(scene);
    this._scenes.splice(index, 1);
    scene._chain = null;
    scene.__onInactive(this);
  }
});

module.exports = type.build();
